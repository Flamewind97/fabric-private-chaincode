/*
Copyright IBM Corp. All Rights Reserved.
Copyright 2020 Intel Corporation

SPDX-License-Identifier: Apache-2.0
*/

package main

import (
	"encoding/csv"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"strconv"
	"time"

	"github.com/hyperledger/fabric-private-chaincode/samples/application/simple-cli-go/pkg"
)

func initConfig() *pkg.Config {

	getStrEnv := func(key string) string {
		val := os.Getenv(key)
		if val == "" {
			panic(fmt.Sprintf("%s not set", key))
		}
		return val
	}

	getBoolEnv := func(key string) bool {
		val := getStrEnv(key)
		ret, err := strconv.ParseBool(val)
		if err != nil {
			if val == "" {
				panic(fmt.Sprintf("invalid bool value for %s", key))
			}
		}
		return ret
	}

	config := &pkg.Config{
		CorePeerAddress:         getStrEnv("CORE_PEER_ADDRESS"),
		CorePeerId:              getStrEnv("CORE_PEER_ID"),
		CorePeerLocalMSPID:      getStrEnv("CORE_PEER_LOCALMSPID"),
		CorePeerMSPConfigPath:   getStrEnv("CORE_PEER_MSPCONFIGPATH"),
		CorePeerTLSCertFile:     getStrEnv("CORE_PEER_TLS_CERT_FILE"),
		CorePeerTLSEnabled:      getBoolEnv("CORE_PEER_TLS_ENABLED"),
		CorePeerTLSKeyFile:      getStrEnv("CORE_PEER_TLS_KEY_FILE"),
		CorePeerTLSRootCertFile: getStrEnv("CORE_PEER_TLS_ROOTCERT_FILE"),
		OrdererCA:               getStrEnv("ORDERER_CA"),
		ChaincodeId:             getStrEnv("CC_NAME"),
		ChannelId:               getStrEnv("CHANNEL_NAME"),
		GatewayConfigPath:       getStrEnv("GATEWAY_CONFIG"),
	}
	return config
}

// func clientSend(client *pkg.Client, sendNum int, keyPrefix string, finish chan string, failed chan int, data chan []string, latency chan time.Duration) {
// 	numOpRep := 4
// 	numKey := sendNum / numOpRep

// 	latencyArr := make([]string, sendNum)
// 	totalDuration := 0 * time.Second
// 	failedNum := 0
// 	for i := 0; i < sendNum; i++ {
// 		keyIndex := i
// 		if keyIndex >= numKey {
// 			keyIndex -= numKey
// 		}
// 		key := keyPrefix + "_" + strconv.Itoa(keyIndex) + "RequiredLongPostfixHereToMatchRequirement"
// 		start := time.Now()
// 		var err error
// 		if (i/numKey)%(2) == 0 {
// 			_, err = client.Invoke("put_state", key, key+"_"+strconv.Itoa(i))
// 		} else {
// 			_, err = client.Invoke("get_state", key)
// 		}
// 		if err != nil {
// 			failedNum++
// 		}
// 		runDuration := time.Since(start)
// 		latencyArr[i] = fmt.Sprintf("%d", runDuration.Milliseconds())
// 		totalDuration += runDuration
// 	}
// 	avgLatency := totalDuration / time.Duration(sendNum)

// 	finish <- keyPrefix
// 	failed <- failedNum
// 	latency <- avgLatency
// 	data <- latencyArr
// }

func clientPut(client *pkg.Client, sendNum int, finish chan time.Duration, failed chan int, data chan []string, setOffset int) {
	latencyArr := make([]string, sendNum)
	totalDuration := 0 * time.Second

	repeatNum := 2
	failedNum := 0
	offset := 3 + setOffset
	for i := offset; i < ((sendNum+1)/repeatNum)+offset; i++ {
		key := strconv.Itoa(i) + "_RequiredLongPostfixHereToMatchRequirement"
		start := time.Now()
		_, err := client.Invoke("createSecret", "Alice", "Alice|Bob", key, key+"_"+strconv.Itoa(i))
		if err != nil {
			failedNum++
		}
		runDuration := time.Since(start)
		latencyArr[i-offset] = fmt.Sprintf("%d", runDuration.Milliseconds())
		totalDuration += runDuration
	}
	for i := ((sendNum + 1) / repeatNum) + offset; i < sendNum+offset; i++ {
		key := strconv.Itoa(i-((sendNum+1)/repeatNum)) + "_RequiredLongPostfixHereToMatchRequirement"
		start := time.Now()
		_, err := client.Invoke("lockSecret", "Alice", key, key+"_"+strconv.Itoa(i))
		if err != nil {
			failedNum++
		}
		runDuration := time.Since(start)
		latencyArr[i-offset] = fmt.Sprintf("%d", runDuration.Milliseconds())
		totalDuration += runDuration
	}

	finish <- totalDuration
	failed <- failedNum
	data <- latencyArr
}

func clientGet(client *pkg.Client, sendNum int, finish chan time.Duration, failed chan int, data chan []string, setOffset int) {
	latencyArr := make([]string, sendNum)
	totalDuration := 0 * time.Second

	repeatNum := 2
	batchSize := sendNum / repeatNum

	failedNum := 0
	for i := 0; i < sendNum; i++ {
		key := strconv.Itoa(i%batchSize+setOffset) + "_RequiredLongPostfixHereToMatchRequirement"
		sig := "Alice"
		if i%2 == 1 {
			sig = "Bob"
		}
		start := time.Now()
		_, err := client.Invoke("revealSecret", sig, key)
		if err != nil {
			failedNum++
		}
		runDuration := time.Since(start)
		latencyArr[i] = fmt.Sprintf("%d", runDuration.Milliseconds())
		totalDuration += runDuration
	}

	finish <- totalDuration
	failed <- failedNum
	data <- latencyArr
}

func runExperiment(config *pkg.Config, clientNum int, numReqEach int, filename string, setOffset int) {
	clientSet := make([]*pkg.Client, clientNum)

	for i := 0; i < clientNum; i++ {
		clientSet[i] = pkg.NewClient(config)
	}
	fmt.Println("clientset:", clientSet)

	finishChan := make(chan time.Duration, 1)
	failedChan := make(chan int, 1)
	dataChan := make(chan []string, 1)

	// create dummy
	_, _ = clientSet[0].Invoke("initSecretKeeperExt")
	for i := 0; i < 3; i++ {
		key := strconv.Itoa(i+setOffset) + "_RequiredLongPostfixHereToMatchRequirement"
		_, _ = clientSet[0].Invoke("createSecret", "Alice", "Alice|Bob", key, key)
	}
	fmt.Println("Dummy build complete, start to send request!")

	start := time.Now()
	for i := 1; i < clientNum; i++ {
		go clientGet(clientSet[i], numReqEach, finishChan, failedChan, dataChan, setOffset)
	}
	go clientPut(clientSet[0], numReqEach, finishChan, failedChan, dataChan, setOffset)

	collect := 0
	totalDuration := 0 * time.Second
	for collect < clientNum {
		select {
		case clientDuration := <-finishChan:
			totalDuration += clientDuration
			collect += 1
		case <-time.After(30 * time.Second):
			fmt.Println("Still waiting for completion, has run:", time.Since(start))
		}
	}
	totalRequest := clientNum * numReqEach
	fmt.Println("Finish", totalRequest, "of requests, duration:", totalDuration/time.Duration(clientNum))

	collect = 0
	totalFailed := 0
	for collect < clientNum {
		failed := <-failedChan
		totalFailed += failed
		collect += 1
	}
	fmt.Printf("Success Rate: %d/%d = %4f\n", totalRequest-totalFailed, totalRequest, float32(totalRequest-totalFailed)/float32(totalRequest))
	fmt.Printf("Throughput(Txn/s): %4f, Avglatency(ms/req): %v\n", float32(totalRequest*1000)/float32(totalDuration.Milliseconds()), totalDuration/time.Duration(totalRequest))

	file, err := os.Create(filename)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	collect = 0
	for collect < clientNum {
		clientData := <-dataChan
		writer.Write(clientData)
		collect += 1
	}

}

func maxInt(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	config := initConfig()
	solution := "ExtMer"
	repeatTime := 3
	clientNum := 20
	numReqEach := 500
	for i := 0; i < repeatTime; i++ {
		filename := fmt.Sprintf("%s_latency_%d_%d_%d.csv", solution, clientNum, numReqEach, i)
		filepath := filepath.Join("/Users/lew/Desktop/fpc-notes/misc/latencyExp/", filename)
		runExperiment(config, clientNum, numReqEach, filepath, i*maxInt(10000, numReqEach*clientNum))
		time.Sleep(3 * time.Second)
		runtime.GC()
	}
}
